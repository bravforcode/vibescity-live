-- Coin Ledger for Secure Server-Side Currency
-- Replaces client-side 'coins' column manipulation

CREATE TABLE IF NOT EXISTS public.coin_ledger (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    amount INT NOT NULL, -- Can be positive (earn) or negative (spend)
    description TEXT NOT NULL, -- e.g., 'Daily Check-in', 'Added Venue'

    -- Idempotency & Security
    transaction_type TEXT NOT NULL, -- 'daily_claim', 'add_venue', 'review', 'spend_boost'
    idempotency_key TEXT, -- Unique key to prevent double-spending/earning (e.g., 'daily_claim_2024-02-04')

    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_coin_ledger_user ON public.coin_ledger(user_id);
CREATE INDEX idx_coin_ledger_idem ON public.coin_ledger(user_id, idempotency_key);

-- RLS: Users can view their own ledger, but CANNOT insert directly.
-- All inserts must go through Edge Functions (RPC or API)
ALTER TABLE public.coin_ledger ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own ledger" ON public.coin_ledger
    FOR SELECT TO authenticated
    USING (auth.uid() = user_id);

-- No INSERT policy for authenticated users -> Must use Service Role (Edge Function)

-- View to get current balance efficiently
CREATE OR REPLACE VIEW public.user_coin_balance AS
SELECT
    user_id,
    SUM(amount) as balance
FROM public.coin_ledger
GROUP BY user_id;

-- Helper RPC to get balance (optional, but convenient)
CREATE OR REPLACE FUNCTION public.get_my_coin_balance()
RETURNS INT
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
    SELECT COALESCE((SELECT balance FROM public.user_coin_balance WHERE user_id = auth.uid()), 0)::INT;
$$;
