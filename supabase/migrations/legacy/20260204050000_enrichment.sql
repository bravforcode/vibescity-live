-- ==========================================
-- 0006: Enrichment Queue & Content Automation
-- ==========================================

-- 1. Enrichment Queue Table
CREATE TABLE IF NOT EXISTS public.enrichment_queue (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    venue_id UUID REFERENCES public.venues(id) ON DELETE CASCADE,
    priority_score INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending', -- pending, processing, completed, failed
    missing_fields TEXT[], -- e.g. ['images', 'video', 'description']
    attempts INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS enrichment_status_idx ON public.enrichment_queue(status);
CREATE INDEX IF NOT EXISTS enrichment_priority_idx ON public.enrichment_queue(priority_score DESC);
CREATE UNIQUE INDEX IF NOT EXISTS enrichment_queue_venue_id_uq ON public.enrichment_queue(venue_id);

-- 2. Trigger to Auto-Queue OSM Venues
-- When a new OSM venue is inserted, if it lacks images, add to queue
CREATE OR REPLACE FUNCTION public.queue_new_osm_venue()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- If source is OSM and no images
IF NEW.source = 'osm' AND (NEW.image_urls IS NULL OR array_length(NEW.image_urls, 1) IS NULL) THEN
        INSERT INTO public.enrichment_queue (venue_id, priority_score, missing_fields)
        VALUES (
            NEW.id,
            10, -- Base priority for new imports
            ARRAY['images']
        )
        ON CONFLICT DO NOTHING;
    END IF;
    RETURN NEW;
END;
$$;

-- Attach Trigger (Check duplication first)
DROP TRIGGER IF EXISTS trg_queue_osm_enrichment ON public.venues;
CREATE TRIGGER trg_queue_osm_enrichment
    AFTER INSERT ON public.venues
    FOR EACH ROW
    EXECUTE FUNCTION public.queue_new_osm_venue();

-- 3. Trigger to Boost Priority on Views
-- If a venue gets viewed but has no images, boost its enrichment priority
-- This uses the shopService increment logic or analytics events
CREATE OR REPLACE FUNCTION public.boost_enrichment_on_view()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- If update touched 'pin_metadata' views or similar (depends on how views are tracked directly on venues)
    -- Or we can expose an RPC to boost priority explicitly.
    -- For now, let's create a helper RPC 'request_enrichment_boost(venue_id)'
    RETURN NEW;
END;
$$;

-- 4. RPC: Request/Boost Enrichment
CREATE OR REPLACE FUNCTION public.request_enrichment_priority(p_venue_id UUID)
RETURNS VOID
LANGUAGE sql
SECURITY DEFINER
AS $$
    INSERT INTO public.enrichment_queue (venue_id, priority_score, status, missing_fields)
    VALUES (p_venue_id, 50, 'pending', ARRAY['images', 'video'])
    ON CONFLICT (venue_id) DO UPDATE
    SET priority_score = enrichment_queue.priority_score + 10;
$$;

-- RLS
ALTER TABLE public.enrichment_queue ENABLE ROW LEVEL SECURITY;

-- Service Role only
CREATE POLICY "Service role manages enrichment" ON public.enrichment_queue
    FOR ALL TO service_role USING (true) WITH CHECK (true);
