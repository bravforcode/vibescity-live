-- ==============================================================================
-- MASTER FIX MIGRATION (Run this SINGLE file to setup everything)
-- ==============================================================================
-- This script includes:
-- 0. Enums (Fix for "type does not exist" error)
-- 1. Analytics Tables
-- 2. Coin Ledger Tables
-- 3. Schema Unification (Venues + Buildings)
-- 4. Order System Fixes (UUID vs BigInt)
-- 5. All RPC Functions (Get Feed, Map Pins, Entitlements)

-- [PART 0] ENUMS
DO $$ BEGIN
    CREATE TYPE pin_type_enum AS ENUM ('normal', 'giant');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- [PART 1] ANALYTICS
CREATE TABLE IF NOT EXISTS public.analytics_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    visitor_id TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    user_agent TEXT,
    device_type TEXT,
    ip_hash TEXT,
    country TEXT,
    city TEXT,
    referrer TEXT,
    last_seen_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_analytics_sessions_visitor ON public.analytics_sessions(visitor_id);

CREATE TABLE IF NOT EXISTS public.analytics_events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id UUID REFERENCES public.analytics_sessions(id),
    event_type TEXT NOT NULL,
    venue_id UUID, -- Fixed: UUID to match venues
    shop_id UUID,  -- Alias for venue_id
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_analytics_events_session ON public.analytics_events(session_id);
CREATE INDEX IF NOT EXISTS idx_analytics_events_type ON public.analytics_events(event_type);

-- [PART 2] COIN LEDGER
CREATE TABLE IF NOT EXISTS public.coin_ledger (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    amount INTEGER NOT NULL,
    transaction_type TEXT NOT NULL,
    description TEXT,
    reference_id TEXT,
    idempotency_key TEXT UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_coin_ledger_user ON public.coin_ledger(user_id);

ALTER TABLE public.user_stats ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users read own stats" ON public.user_stats;
CREATE POLICY "Users read own stats" ON public.user_stats FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Service role manages stats" ON public.user_stats;
CREATE POLICY "Service role manages stats" ON public.user_stats FOR ALL TO service_role USING (true);

-- [PART 3] VENUES SCHEMA FIXES
ALTER TABLE public.venues
    ADD COLUMN IF NOT EXISTS pin_type pin_type_enum NOT NULL DEFAULT 'normal',
    ADD COLUMN IF NOT EXISTS pin_metadata JSONB NOT NULL DEFAULT '{}'::JSONB,
    ADD COLUMN IF NOT EXISTS is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    ADD COLUMN IF NOT EXISTS verified_until TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS glow_until TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS boost_until TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS giant_until TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS visibility_score INTEGER NOT NULL DEFAULT 0;

-- [PART 4] ORDERS SYSTEM
CREATE TABLE IF NOT EXISTS public.orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    venue_id UUID REFERENCES public.venues(id), -- Fixed: UUID
    shop_id UUID, -- Legacy alias (UUID now)
    total_amount NUMERIC,
    status TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    provider TEXT,
    provider_order_id TEXT
);

-- Ensure order_items exists
CREATE TABLE IF NOT EXISTS public.order_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id UUID REFERENCES public.orders(id),
    sku TEXT,
    quantity INTEGER,
    price NUMERIC
);

-- [PART 5] ENRICHMENT QUEUE
CREATE TABLE IF NOT EXISTS public.enrichment_queue (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    venue_id UUID REFERENCES public.venues(id) ON DELETE CASCADE, -- Fixed: UUID
    priority_score INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending',
    missing_fields TEXT[],
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- [PART 6] BUILDINGS
ALTER TABLE public.buildings ADD COLUMN IF NOT EXISTS floors JSONB DEFAULT '{}'::JSONB;

-- [PART 7] RPC FUNCTIONS (The Brains)

-- RPC: get_feed_cards
DROP FUNCTION IF EXISTS public.get_feed_cards(double precision, double precision);
CREATE OR REPLACE FUNCTION public.get_feed_cards(p_lat double precision, p_lng double precision)
RETURNS TABLE (
  id UUID, name text, category text, distance_km double precision,
  pin_type pin_type_enum, pin_metadata jsonb, is_verified boolean,
  verified_active boolean, glow_active boolean, boost_active boolean, giant_active boolean,
  images text[], status text
) LANGUAGE sql STABLE AS $$
  SELECT v.id, v.name, v.category,
    ROUND((ST_Distance(v.location::geometry, ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geometry) / 1000.0)::numeric, 2)::double precision,
    v.pin_type, v.pin_metadata, v.is_verified,
    (v.verified_until > NOW()), (v.glow_until > NOW()), (v.boost_until > NOW()), (v.giant_until > NOW()),
    v.image_urls::text[], 'active'
  FROM public.venues v
  ORDER BY v.location <-> ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326) ASC LIMIT 30;
$$;

-- RPC: get_map_pins
DROP FUNCTION IF EXISTS public.get_map_pins(double precision, double precision, double precision, double precision, int);
CREATE OR REPLACE FUNCTION public.get_map_pins(
  p_min_lat double precision, p_min_lng double precision, p_max_lat double precision, p_max_lng double precision, p_zoom int
) RETURNS TABLE (
  id UUID, name text, lat double precision, lng double precision,
  pin_type pin_type_enum, pin_metadata jsonb, visibility_score int,
  is_verified boolean, verified_active boolean, glow_active boolean, boost_active boolean, giant_active boolean
) LANGUAGE plpgsql STABLE AS $$
BEGIN
  IF p_zoom < 13 THEN
    RETURN QUERY SELECT v.id, v.name, ST_Y(v.location::geometry), ST_X(v.location::geometry),
      v.pin_type, v.pin_metadata, v.visibility_score, v.is_verified,
      (v.verified_until > NOW()), (v.glow_until > NOW()), (v.boost_until > NOW()), (v.giant_until > NOW())
    FROM public.venues v WHERE v.pin_type='giant' AND ST_Intersects(v.location::geometry, ST_MakeEnvelope(p_min_lng, p_min_lat, p_max_lng, p_max_lat, 4326));
  ELSE
    RETURN QUERY SELECT v.id, v.name, ST_Y(v.location::geometry), ST_X(v.location::geometry),
      v.pin_type, v.pin_metadata, v.visibility_score, v.is_verified,
      (v.verified_until > NOW()), (v.glow_until > NOW()), (v.boost_until > NOW()), (v.giant_until > NOW())
    FROM public.venues v WHERE ST_Intersects(v.location::geometry, ST_MakeEnvelope(p_min_lng, p_min_lat, p_max_lng, p_max_lat, 4326)) LIMIT 1000;
  END IF;
END;
$$;

-- RPC: Apply Entitlements
CREATE OR REPLACE FUNCTION public.apply_entitlements(p_order_id UUID) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_venue_id UUID;
BEGIN
    SELECT venue_id INTO v_venue_id FROM public.orders WHERE id = p_order_id;
    IF v_venue_id IS NOT NULL THEN
        UPDATE public.venues SET pin_type = 'giant', giant_until = NOW() + INTERVAL '30 days' WHERE id = v_venue_id;
    END IF;
END;
$$;

-- RPC: Expire Entitlements
CREATE OR REPLACE FUNCTION public.expire_entitlements() RETURNS TABLE(updated_count INT) LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    UPDATE public.venues SET pin_type = 'normal', giant_until = NULL WHERE pin_type = 'giant' AND giant_until < NOW();
    RETURN QUERY SELECT 1;
END;
$$;
