-- Entertainment Map Upgrade - Hotspot, Effect Queue, Zoom Cache
-- Performance-first data plane for realtime map visuals

-- 1) Hotspot aggregate table (5-minute buckets)
CREATE TABLE IF NOT EXISTS public.hotspot_5m (
  bucket_start TIMESTAMPTZ NOT NULL,
  venue_ref TEXT NOT NULL,
  event_count INTEGER NOT NULL DEFAULT 0,
  unique_visitors INTEGER NOT NULL DEFAULT 0,
  score NUMERIC(12, 4) NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (bucket_start, venue_ref)
);

CREATE INDEX IF NOT EXISTS hotspot_5m_score_idx
  ON public.hotspot_5m (score DESC, event_count DESC, unique_visitors DESC);
CREATE INDEX IF NOT EXISTS hotspot_5m_recent_idx
  ON public.hotspot_5m (bucket_start DESC);
CREATE INDEX IF NOT EXISTS hotspot_5m_venue_ref_idx
  ON public.hotspot_5m (venue_ref);

-- 2) Effect queue table (short-lived burst effects)
CREATE TABLE IF NOT EXISTS public.map_effect_queue (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  venue_ref TEXT NOT NULL,
  effect_type TEXT NOT NULL,
  payload JSONB NOT NULL DEFAULT '{}'::JSONB,
  priority SMALLINT NOT NULL DEFAULT 0,
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '8 seconds'),
  consumed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS map_effect_queue_pending_idx
  ON public.map_effect_queue (priority DESC, created_at ASC)
  WHERE consumed_at IS NULL;
CREATE INDEX IF NOT EXISTS map_effect_queue_expiry_idx
  ON public.map_effect_queue (expires_at);
CREATE INDEX IF NOT EXISTS map_effect_queue_venue_idx
  ON public.map_effect_queue (venue_ref);

-- 3) Zoom-bucket pin cache
CREATE TABLE IF NOT EXISTS public.map_pins_zoom_cache (
  zoom_bucket SMALLINT NOT NULL,
  venue_ref TEXT NOT NULL,
  lat DOUBLE PRECISION NOT NULL,
  lng DOUBLE PRECISION NOT NULL,
  pin_type TEXT NOT NULL DEFAULT 'normal',
  pin_metadata JSONB NOT NULL DEFAULT '{}'::JSONB,
  visibility_score INTEGER NOT NULL DEFAULT 0,
  verified_active BOOLEAN NOT NULL DEFAULT FALSE,
  glow_active BOOLEAN NOT NULL DEFAULT FALSE,
  boost_active BOOLEAN NOT NULL DEFAULT FALSE,
  giant_active BOOLEAN NOT NULL DEFAULT FALSE,
  vibe_score NUMERIC(10, 2) NOT NULL DEFAULT 0,
  priority_score NUMERIC(12, 2) NOT NULL DEFAULT 0,
  refreshed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (zoom_bucket, venue_ref)
);

CREATE INDEX IF NOT EXISTS map_pins_zoom_cache_lookup_idx
  ON public.map_pins_zoom_cache (zoom_bucket, refreshed_at DESC, priority_score DESC);
CREATE INDEX IF NOT EXISTS map_pins_zoom_cache_latlng_idx
  ON public.map_pins_zoom_cache (zoom_bucket, lat, lng);

-- 4) Hotspot rollup function (every 5 minutes)
CREATE OR REPLACE FUNCTION public.rollup_hotspot_5m()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  WITH source_events AS (
    SELECT
      (
        date_trunc('minute', e.created_at)
        - make_interval(mins => (EXTRACT(MINUTE FROM e.created_at)::INT % 5))
      ) AS bucket_start,
      COALESCE(
        NULLIF(e.metadata->>'venue_ref', ''),
        NULLIF(e.metadata->>'shop_id', ''),
        e.shop_id::TEXT
      ) AS venue_ref,
      COUNT(*)::INT AS event_count,
      COUNT(DISTINCT COALESCE(s.visitor_id, e.metadata->>'visitor_id'))::INT AS unique_visitors
    FROM public.analytics_events e
    LEFT JOIN public.analytics_sessions s ON s.id = e.session_id
    WHERE e.created_at >= NOW() - INTERVAL '30 minutes'
      AND COALESCE(
        NULLIF(e.metadata->>'venue_ref', ''),
        NULLIF(e.metadata->>'shop_id', ''),
        e.shop_id::TEXT
      ) IS NOT NULL
    GROUP BY 1, 2
  ),
  upserted AS (
    INSERT INTO public.hotspot_5m (
      bucket_start,
      venue_ref,
      event_count,
      unique_visitors,
      score,
      updated_at
    )
    SELECT
      se.bucket_start,
      se.venue_ref,
      se.event_count,
      se.unique_visitors,
      ROUND((se.event_count * 1.0 + se.unique_visitors * 1.5)::NUMERIC, 4),
      NOW()
    FROM source_events se
    ON CONFLICT (bucket_start, venue_ref)
    DO UPDATE SET
      event_count = EXCLUDED.event_count,
      unique_visitors = EXCLUDED.unique_visitors,
      score = EXCLUDED.score,
      updated_at = NOW()
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_rows FROM upserted;

  RETURN COALESCE(v_rows, 0);
END;
$$;

-- 5) Queue enqueue/dequeue functions
CREATE OR REPLACE FUNCTION public.enqueue_map_effect(
  p_venue_ref TEXT,
  p_effect_type TEXT,
  p_payload JSONB DEFAULT '{}'::JSONB,
  p_priority SMALLINT DEFAULT 0,
  p_ttl_seconds INTEGER DEFAULT 8
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_id BIGINT;
BEGIN
  INSERT INTO public.map_effect_queue (
    venue_ref,
    effect_type,
    payload,
    priority,
    expires_at
  )
  VALUES (
    p_venue_ref,
    p_effect_type,
    COALESCE(p_payload, '{}'::JSONB),
    COALESCE(p_priority, 0),
    NOW() + make_interval(secs => GREATEST(COALESCE(p_ttl_seconds, 8), 1))
  )
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$;

CREATE OR REPLACE FUNCTION public.dequeue_map_effects(p_limit INTEGER DEFAULT 50)
RETURNS TABLE (
  id BIGINT,
  venue_ref TEXT,
  effect_type TEXT,
  payload JSONB,
  priority SMALLINT,
  created_at TIMESTAMPTZ
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  WITH picked AS (
    SELECT q.id
    FROM public.map_effect_queue q
    WHERE q.consumed_at IS NULL
      AND q.expires_at > NOW()
    ORDER BY q.priority DESC, q.created_at ASC
    LIMIT GREATEST(COALESCE(p_limit, 50), 1)
    FOR UPDATE SKIP LOCKED
  ),
  updated AS (
    UPDATE public.map_effect_queue q
    SET consumed_at = NOW()
    FROM picked p
    WHERE q.id = p.id
    RETURNING q.id, q.venue_ref, q.effect_type, q.payload, q.priority, q.created_at
  )
  SELECT * FROM updated;
$$;

CREATE OR REPLACE FUNCTION public.get_hotspot_snapshot(p_limit INTEGER DEFAULT 20)
RETURNS TABLE (
  bucket_start TIMESTAMPTZ,
  venue_ref TEXT,
  event_count INTEGER,
  unique_visitors INTEGER,
  score NUMERIC
)
LANGUAGE sql
STABLE
AS $$
  WITH latest AS (
    SELECT MAX(bucket_start) AS bucket_start
    FROM public.hotspot_5m
  )
  SELECT
    h.bucket_start,
    h.venue_ref,
    h.event_count,
    h.unique_visitors,
    h.score
  FROM public.hotspot_5m h
  CROSS JOIN latest l
  WHERE h.bucket_start = l.bucket_start
  ORDER BY h.score DESC, h.event_count DESC
  LIMIT GREATEST(COALESCE(p_limit, 20), 1);
$$;

-- 6) Refresh zoom cache
CREATE OR REPLACE FUNCTION public.refresh_map_pins_zoom_cache()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  WITH base_rows AS (
    SELECT
      v.id::TEXT AS venue_ref,
      v.name,
      v.latitude::DOUBLE PRECISION AS lat,
      v.longitude::DOUBLE PRECISION AS lng,
      COALESCE(v.pin_type::TEXT, 'normal') AS pin_type,
      COALESCE(v.pin_metadata, '{}'::JSONB) AS pin_metadata,
      COALESCE(v.visibility_score, 0) AS visibility_score,
      (v.verified_until IS NOT NULL AND v.verified_until > NOW()) AS verified_active,
      (v.glow_until IS NOT NULL AND v.glow_until > NOW()) AS glow_active,
      (v.boost_until IS NOT NULL AND v.boost_until > NOW()) AS boost_active,
      (v.giant_until IS NOT NULL AND v.giant_until > NOW()) AS giant_active
    FROM public.venues v
    WHERE v.latitude IS NOT NULL
      AND v.longitude IS NOT NULL
  ),
  expanded AS (
    SELECT
      z.zoom_bucket,
      b.venue_ref,
      b.lat,
      b.lng,
      b.pin_type,
      b.pin_metadata,
      b.visibility_score,
      b.verified_active,
      b.glow_active,
      b.boost_active,
      b.giant_active,
      ROUND((b.visibility_score + CASE WHEN b.boost_active THEN 30 ELSE 0 END)::NUMERIC, 2) AS vibe_score,
      ROUND(
        (
          b.visibility_score
          + CASE WHEN b.boost_active THEN 100 ELSE 0 END
          + CASE WHEN b.giant_active THEN 160 ELSE 0 END
          + CASE WHEN b.verified_active THEN 20 ELSE 0 END
        )::NUMERIC
      , 2) AS priority_score
    FROM base_rows b
    CROSS JOIN (VALUES (12::SMALLINT), (14::SMALLINT), (16::SMALLINT)) AS z(zoom_bucket)
    WHERE
      (
        z.zoom_bucket = 12
        AND (
          b.giant_active
          OR b.boost_active
          OR b.verified_active
          OR b.visibility_score > 20
        )
      )
      OR (
        z.zoom_bucket = 14
        AND (
          b.giant_active
          OR b.boost_active
          OR b.visibility_score > 0
          OR b.verified_active
        )
      )
      OR z.zoom_bucket = 16
  ),
  upserted AS (
    INSERT INTO public.map_pins_zoom_cache (
      zoom_bucket,
      venue_ref,
      lat,
      lng,
      pin_type,
      pin_metadata,
      visibility_score,
      verified_active,
      glow_active,
      boost_active,
      giant_active,
      vibe_score,
      priority_score,
      refreshed_at
    )
    SELECT
      e.zoom_bucket,
      e.venue_ref,
      e.lat,
      e.lng,
      e.pin_type,
      e.pin_metadata,
      e.visibility_score,
      e.verified_active,
      e.glow_active,
      e.boost_active,
      e.giant_active,
      e.vibe_score,
      e.priority_score,
      NOW()
    FROM expanded e
    ON CONFLICT (zoom_bucket, venue_ref)
    DO UPDATE SET
      lat = EXCLUDED.lat,
      lng = EXCLUDED.lng,
      pin_type = EXCLUDED.pin_type,
      pin_metadata = EXCLUDED.pin_metadata,
      visibility_score = EXCLUDED.visibility_score,
      verified_active = EXCLUDED.verified_active,
      glow_active = EXCLUDED.glow_active,
      boost_active = EXCLUDED.boost_active,
      giant_active = EXCLUDED.giant_active,
      vibe_score = EXCLUDED.vibe_score,
      priority_score = EXCLUDED.priority_score,
      refreshed_at = NOW()
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_rows FROM upserted;

  DELETE FROM public.map_pins_zoom_cache
  WHERE refreshed_at < NOW() - INTERVAL '2 hours';

  RETURN COALESCE(v_rows, 0);
END;
$$;

-- 7) Cache-aware get_map_pins (frontend RPC)
DROP FUNCTION IF EXISTS public.get_map_pins(
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  INTEGER
);

CREATE OR REPLACE FUNCTION public.get_map_pins(
  p_min_lat DOUBLE PRECISION,
  p_min_lng DOUBLE PRECISION,
  p_max_lat DOUBLE PRECISION,
  p_max_lng DOUBLE PRECISION,
  p_zoom INTEGER
)
RETURNS TABLE (
  id TEXT,
  name TEXT,
  lat DOUBLE PRECISION,
  lng DOUBLE PRECISION,
  pin_type TEXT,
  pin_metadata JSONB,
  visibility_score INTEGER,
  is_verified BOOLEAN,
  verified_active BOOLEAN,
  glow_active BOOLEAN,
  boost_active BOOLEAN,
  giant_active BOOLEAN
)
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_bucket SMALLINT := CASE
    WHEN p_zoom < 13 THEN 12
    WHEN p_zoom < 15 THEN 14
    ELSE 16
  END;
  v_limit INTEGER := CASE
    WHEN p_zoom < 13 THEN 120
    WHEN p_zoom < 15 THEN 320
    ELSE 1200
  END;
BEGIN
  RETURN QUERY
  SELECT
    c.venue_ref AS id,
    COALESCE(v.name, c.pin_metadata->>'name', c.venue_ref) AS name,
    c.lat,
    c.lng,
    COALESCE(c.pin_type, 'normal') AS pin_type,
    COALESCE(c.pin_metadata, '{}'::JSONB) AS pin_metadata,
    COALESCE(c.visibility_score, 0) AS visibility_score,
    COALESCE(v.is_verified, FALSE) AS is_verified,
    COALESCE(c.verified_active, FALSE) AS verified_active,
    COALESCE(c.glow_active, FALSE) AS glow_active,
    COALESCE(c.boost_active, FALSE) AS boost_active,
    COALESCE(c.giant_active, FALSE) AS giant_active
  FROM public.map_pins_zoom_cache c
  LEFT JOIN public.venues v ON v.id::TEXT = c.venue_ref
  WHERE c.zoom_bucket = v_bucket
    AND c.refreshed_at > NOW() - INTERVAL '30 minutes'
    AND c.lat BETWEEN p_min_lat AND p_max_lat
    AND c.lng BETWEEN p_min_lng AND p_max_lng
  ORDER BY c.priority_score DESC, c.visibility_score DESC
  LIMIT v_limit;

  IF FOUND THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    v.id::TEXT AS id,
    v.name,
    v.latitude::DOUBLE PRECISION AS lat,
    v.longitude::DOUBLE PRECISION AS lng,
    COALESCE(v.pin_type::TEXT, 'normal') AS pin_type,
    COALESCE(v.pin_metadata, '{}'::JSONB) AS pin_metadata,
    COALESCE(v.visibility_score, 0) AS visibility_score,
    COALESCE(v.is_verified, FALSE) AS is_verified,
    (v.verified_until IS NOT NULL AND v.verified_until > NOW()) AS verified_active,
    (v.glow_until IS NOT NULL AND v.glow_until > NOW()) AS glow_active,
    (v.boost_until IS NOT NULL AND v.boost_until > NOW()) AS boost_active,
    (v.giant_until IS NOT NULL AND v.giant_until > NOW()) AS giant_active
  FROM public.venues v
  WHERE v.latitude BETWEEN p_min_lat AND p_max_lat
    AND v.longitude BETWEEN p_min_lng AND p_max_lng
  ORDER BY
    (
      COALESCE(v.visibility_score, 0)
      + CASE WHEN v.boost_until > NOW() THEN 100 ELSE 0 END
      + CASE WHEN v.giant_until > NOW() THEN 160 ELSE 0 END
    ) DESC
  LIMIT v_limit;
END;
$$;

-- 8) Query indexes for map reads
CREATE INDEX IF NOT EXISTS venues_location_gist_idx
  ON public.venues
  USING gist (ST_SetSRID(ST_MakePoint(longitude, latitude), 4326))
  WHERE latitude IS NOT NULL AND longitude IS NOT NULL;

CREATE INDEX IF NOT EXISTS venues_rank_idx
  ON public.venues (visibility_score DESC, boost_until DESC NULLS LAST);

CREATE INDEX IF NOT EXISTS venues_id_text_idx
  ON public.venues ((id::TEXT));

-- 9) Grants
GRANT EXECUTE ON FUNCTION public.rollup_hotspot_5m() TO service_role;
GRANT EXECUTE ON FUNCTION public.enqueue_map_effect(TEXT, TEXT, JSONB, SMALLINT, INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION public.dequeue_map_effects(INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION public.refresh_map_pins_zoom_cache() TO service_role;
GRANT EXECUTE ON FUNCTION public.get_hotspot_snapshot(INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_map_pins(
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  DOUBLE PRECISION,
  INTEGER
) TO anon, authenticated, service_role;

-- 10) Optional cron jobs (if pg_cron exists)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
    IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'hotspot-rollup-5m') THEN
      PERFORM cron.schedule(
        'hotspot-rollup-5m',
        '*/5 * * * *',
        'SELECT public.rollup_hotspot_5m();'
      );
    END IF;

    IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'map-pins-cache-refresh') THEN
      PERFORM cron.schedule(
        'map-pins-cache-refresh',
        '*/10 * * * *',
        'SELECT public.refresh_map_pins_zoom_cache();'
      );
    END IF;
  END IF;
END;
$$;
