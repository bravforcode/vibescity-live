-- Entertainment Map Upgrade - Analytics partition + retention
-- Policy: 90 days hot raw + 365 days daily archive

-- 1) Partitioned raw analytics table
CREATE TABLE IF NOT EXISTS public.analytics_events_p (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY,
  session_id UUID,
  event_type TEXT NOT NULL,
  shop_id UUID,
  venue_ref TEXT,
  metadata JSONB NOT NULL DEFAULT '{}'::JSONB,
  visitor_id TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
) PARTITION BY RANGE (created_at);

CREATE INDEX IF NOT EXISTS analytics_events_p_created_idx
  ON public.analytics_events_p (created_at DESC);
CREATE INDEX IF NOT EXISTS analytics_events_p_venue_ref_idx
  ON public.analytics_events_p (venue_ref);
CREATE INDEX IF NOT EXISTS analytics_events_p_shop_id_idx
  ON public.analytics_events_p (shop_id);
CREATE INDEX IF NOT EXISTS analytics_events_p_type_idx
  ON public.analytics_events_p (event_type);

-- 2) Ensure monthly partitions
CREATE OR REPLACE FUNCTION public.ensure_analytics_partition(p_month DATE)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
  v_start DATE := date_trunc('month', p_month)::DATE;
  v_end DATE := (date_trunc('month', p_month) + INTERVAL '1 month')::DATE;
  v_name TEXT := format('analytics_events_p_%s', to_char(v_start, 'YYYY_MM'));
BEGIN
  IF to_regclass('public.' || v_name) IS NULL THEN
    EXECUTE format(
      'CREATE TABLE public.%I PARTITION OF public.analytics_events_p FOR VALUES FROM (%L) TO (%L)',
      v_name,
      v_start::TEXT,
      v_end::TEXT
    );
  END IF;
END;
$$;

DO $$
DECLARE
  i INTEGER;
  v_month DATE;
BEGIN
  FOR i IN -3..12 LOOP
    v_month := (date_trunc('month', CURRENT_DATE) + (i || ' month')::INTERVAL)::DATE;
    PERFORM public.ensure_analytics_partition(v_month);
  END LOOP;
END;
$$;

-- 3) Daily archive table
CREATE TABLE IF NOT EXISTS public.analytics_events_archive_daily (
  day DATE NOT NULL,
  venue_ref TEXT NOT NULL,
  event_type TEXT NOT NULL,
  events_count BIGINT NOT NULL DEFAULT 0,
  unique_visitors BIGINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (day, venue_ref, event_type)
);

CREATE INDEX IF NOT EXISTS analytics_events_archive_daily_day_idx
  ON public.analytics_events_archive_daily (day DESC);
CREATE INDEX IF NOT EXISTS analytics_events_archive_daily_venue_idx
  ON public.analytics_events_archive_daily (venue_ref);

-- 4) Archive + purge functions
CREATE OR REPLACE FUNCTION public.rollup_analytics_archive_daily(p_day DATE DEFAULT (CURRENT_DATE - 1))
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  WITH aggregated AS (
    SELECT
      p_day AS day,
      COALESCE(
        NULLIF(e.venue_ref, ''),
        NULLIF(e.metadata->>'venue_ref', ''),
        NULLIF(e.metadata->>'shop_id', ''),
        e.shop_id::TEXT
      ) AS venue_ref,
      e.event_type,
      COUNT(*)::BIGINT AS events_count,
      COUNT(DISTINCT COALESCE(e.visitor_id, s.visitor_id, e.metadata->>'visitor_id'))::BIGINT AS unique_visitors
    FROM public.analytics_events_p e
    LEFT JOIN public.analytics_sessions s ON s.id = e.session_id
    WHERE e.created_at >= p_day::TIMESTAMPTZ
      AND e.created_at < (p_day::TIMESTAMPTZ + INTERVAL '1 day')
      AND COALESCE(
        NULLIF(e.venue_ref, ''),
        NULLIF(e.metadata->>'venue_ref', ''),
        NULLIF(e.metadata->>'shop_id', ''),
        e.shop_id::TEXT
      ) IS NOT NULL
    GROUP BY e.event_type, venue_ref
  ),
  upserted AS (
    INSERT INTO public.analytics_events_archive_daily (
      day,
      venue_ref,
      event_type,
      events_count,
      unique_visitors,
      created_at
    )
    SELECT
      a.day,
      a.venue_ref,
      a.event_type,
      a.events_count,
      a.unique_visitors,
      NOW()
    FROM aggregated a
    ON CONFLICT (day, venue_ref, event_type)
    DO UPDATE SET
      events_count = EXCLUDED.events_count,
      unique_visitors = EXCLUDED.unique_visitors,
      created_at = NOW()
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_rows FROM upserted;

  RETURN COALESCE(v_rows, 0);
END;
$$;

CREATE OR REPLACE FUNCTION public.purge_analytics_raw(p_keep_days INTEGER DEFAULT 90)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  DELETE FROM public.analytics_events_p
  WHERE created_at < NOW() - make_interval(days => GREATEST(COALESCE(p_keep_days, 90), 1));

  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN COALESCE(v_rows, 0);
END;
$$;

CREATE OR REPLACE FUNCTION public.purge_analytics_archive(p_keep_days INTEGER DEFAULT 365)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  DELETE FROM public.analytics_events_archive_daily
  WHERE day < CURRENT_DATE - GREATEST(COALESCE(p_keep_days, 365), 1);

  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN COALESCE(v_rows, 0);
END;
$$;

-- 5) Optional backfill from legacy raw table (non-destructive)
INSERT INTO public.analytics_events_p (
  session_id,
  event_type,
  shop_id,
  venue_ref,
  metadata,
  visitor_id,
  created_at
)
SELECT
  e.session_id,
  e.event_type,
  e.shop_id,
  COALESCE(
    NULLIF(e.metadata->>'venue_ref', ''),
    NULLIF(e.metadata->>'shop_id', ''),
    e.shop_id::TEXT
  ) AS venue_ref,
  COALESCE(e.metadata, '{}'::JSONB),
  s.visitor_id,
  e.created_at
FROM public.analytics_events e
LEFT JOIN public.analytics_sessions s ON s.id = e.session_id
WHERE e.created_at >= NOW() - INTERVAL '120 days'
ON CONFLICT DO NOTHING;

-- 6) Grants
GRANT EXECUTE ON FUNCTION public.ensure_analytics_partition(DATE) TO service_role;
GRANT EXECUTE ON FUNCTION public.rollup_analytics_archive_daily(DATE) TO service_role;
GRANT EXECUTE ON FUNCTION public.purge_analytics_raw(INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION public.purge_analytics_archive(INTEGER) TO service_role;

-- 7) Cron schedules (if available)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
    IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'analytics-archive-rollup-daily') THEN
      PERFORM cron.schedule(
        'analytics-archive-rollup-daily',
        '5 0 * * *',
        'SELECT public.rollup_analytics_archive_daily(CURRENT_DATE - 1);'
      );
    END IF;

    IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'analytics-raw-purge-daily') THEN
      PERFORM cron.schedule(
        'analytics-raw-purge-daily',
        '20 0 * * *',
        'SELECT public.purge_analytics_raw(90);'
      );
    END IF;

    IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'analytics-archive-purge-daily') THEN
      PERFORM cron.schedule(
        'analytics-archive-purge-daily',
        '35 0 * * *',
        'SELECT public.purge_analytics_archive(365);'
      );
    END IF;
  END IF;
END;
$$;
