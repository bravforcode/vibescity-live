-- Gamification persistence hardening
-- Daily check-in + Lucky wheel are now server authoritative
-- NOTE: This file is SQL-only. Do not put `supabase ...` CLI commands here.
-- Run CLI commands in terminal (for example: `supabase db push`).

-- 1) Daily check-ins
CREATE TABLE IF NOT EXISTS public.daily_checkins (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  checkin_date DATE NOT NULL,
  streak_day SMALLINT NOT NULL CHECK (streak_day BETWEEN 1 AND 7),
  reward_coins INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, checkin_date)
);

CREATE INDEX IF NOT EXISTS daily_checkins_user_date_idx
  ON public.daily_checkins (user_id, checkin_date DESC);

-- 2) Lucky wheel spins
CREATE TABLE IF NOT EXISTS public.lucky_wheel_spins (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  spin_date DATE NOT NULL,
  prize_code TEXT NOT NULL,
  prize_label TEXT NOT NULL,
  reward_coins INTEGER NOT NULL DEFAULT 0,
  metadata JSONB NOT NULL DEFAULT '{}'::JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, spin_date)
);

CREATE INDEX IF NOT EXISTS lucky_wheel_spins_user_date_idx
  ON public.lucky_wheel_spins (user_id, spin_date DESC);

ALTER TABLE public.daily_checkins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.lucky_wheel_spins ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can read own daily checkins" ON public.daily_checkins;
CREATE POLICY "Users can read own daily checkins"
  ON public.daily_checkins
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can read own lucky wheel spins" ON public.lucky_wheel_spins;
CREATE POLICY "Users can read own lucky wheel spins"
  ON public.lucky_wheel_spins
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- 3) Helper: current coin balance
CREATE OR REPLACE FUNCTION public.get_coin_balance_for_user(p_user_id UUID)
RETURNS INTEGER
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE(SUM(amount), 0)::INTEGER
  FROM public.coin_ledger
  WHERE user_id = p_user_id;
$$;

-- 4) Daily check-in status RPC
CREATE OR REPLACE FUNCTION public.get_daily_checkin_status()
RETURNS JSONB
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_today DATE := CURRENT_DATE;
  v_last RECORD;
  v_total_days INTEGER := 0;
  v_can_claim BOOLEAN := TRUE;
  v_next_streak INTEGER := 1;
  v_next_reward INTEGER := 10;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized' USING ERRCODE = '42501';
  END IF;

  SELECT COUNT(*)::INTEGER
  INTO v_total_days
  FROM public.daily_checkins
  WHERE user_id = v_user_id;

  SELECT checkin_date, streak_day, reward_coins, created_at
  INTO v_last
  FROM public.daily_checkins
  WHERE user_id = v_user_id
  ORDER BY checkin_date DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM public.daily_checkins
    WHERE user_id = v_user_id
      AND checkin_date = v_today
  ) THEN
    v_can_claim := FALSE;
  END IF;

  IF v_last.checkin_date IS NOT NULL THEN
    IF v_can_claim AND v_last.checkin_date = (v_today - 1) THEN
      v_next_streak := LEAST(v_last.streak_day + 1, 7);
    ELSIF v_can_claim AND v_last.checkin_date < (v_today - 1) THEN
      v_next_streak := 1;
    ELSE
      v_next_streak := v_last.streak_day;
    END IF;
  END IF;

  v_next_reward := CASE v_next_streak
    WHEN 1 THEN 10
    WHEN 2 THEN 15
    WHEN 3 THEN 20
    WHEN 4 THEN 25
    WHEN 5 THEN 30
    WHEN 6 THEN 40
    WHEN 7 THEN 100
    ELSE 10
  END;

  RETURN jsonb_build_object(
    'success', TRUE,
    'can_claim_today', v_can_claim,
    'streak', COALESCE(v_last.streak_day, 0),
    'total_days', v_total_days,
    'last_checkin_at', v_last.created_at,
    'next_streak', v_next_streak,
    'next_reward_coins', v_next_reward,
    'balance', public.get_coin_balance_for_user(v_user_id)
  );
END;
$$;

-- 5) Daily check-in claim RPC (idempotent per day)
CREATE OR REPLACE FUNCTION public.claim_daily_checkin()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_today DATE := CURRENT_DATE;
  v_last RECORD;
  v_existing RECORD;
  v_streak INTEGER := 1;
  v_reward INTEGER := 10;
  v_balance INTEGER := 0;
  v_idempotency_key TEXT := format('daily_checkin:%s', CURRENT_DATE::TEXT);
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized' USING ERRCODE = '42501';
  END IF;

  SELECT streak_day, reward_coins, created_at
  INTO v_existing
  FROM public.daily_checkins
  WHERE user_id = v_user_id
    AND checkin_date = v_today
  LIMIT 1;

  IF v_existing.streak_day IS NOT NULL THEN
    v_balance := public.get_coin_balance_for_user(v_user_id);
    RETURN jsonb_build_object(
      'success', FALSE,
      'already_claimed', TRUE,
      'streak', v_existing.streak_day,
      'reward_coins', v_existing.reward_coins,
      'total_days', (
        SELECT COUNT(*)::INTEGER
        FROM public.daily_checkins
        WHERE user_id = v_user_id
      ),
      'claimed_at', v_existing.created_at,
      'balance', v_balance
    );
  END IF;

  SELECT checkin_date, streak_day
  INTO v_last
  FROM public.daily_checkins
  WHERE user_id = v_user_id
  ORDER BY checkin_date DESC
  LIMIT 1;

  IF v_last.checkin_date = (v_today - 1) THEN
    v_streak := LEAST(v_last.streak_day + 1, 7);
  ELSIF v_last.checkin_date = v_today THEN
    v_streak := v_last.streak_day;
  ELSE
    v_streak := 1;
  END IF;

  v_reward := CASE v_streak
    WHEN 1 THEN 10
    WHEN 2 THEN 15
    WHEN 3 THEN 20
    WHEN 4 THEN 25
    WHEN 5 THEN 30
    WHEN 6 THEN 40
    WHEN 7 THEN 100
    ELSE 10
  END;

  INSERT INTO public.daily_checkins (
    user_id,
    checkin_date,
    streak_day,
    reward_coins
  )
  VALUES (
    v_user_id,
    v_today,
    v_streak,
    v_reward
  );

  IF NOT EXISTS (
    SELECT 1
    FROM public.coin_ledger
    WHERE user_id = v_user_id
      AND idempotency_key = v_idempotency_key
  ) THEN
    INSERT INTO public.coin_ledger (
      user_id,
      amount,
      description,
      transaction_type,
      idempotency_key,
      metadata
    )
    VALUES (
      v_user_id,
      v_reward,
      format('Daily check-in reward (day %s)', v_streak),
      'daily_checkin',
      v_idempotency_key,
      jsonb_build_object(
        'streak_day', v_streak,
        'reward_coins', v_reward
      )
    );
  END IF;

  v_balance := public.get_coin_balance_for_user(v_user_id);

  RETURN jsonb_build_object(
    'success', TRUE,
    'already_claimed', FALSE,
    'streak', v_streak,
    'reward_coins', v_reward,
    'total_days', (
      SELECT COUNT(*)::INTEGER
      FROM public.daily_checkins
      WHERE user_id = v_user_id
    ),
    'claimed_at', NOW(),
    'balance', v_balance
  );
END;
$$;

-- 6) Lucky wheel status RPC
CREATE OR REPLACE FUNCTION public.get_lucky_wheel_status()
RETURNS JSONB
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_today DATE := CURRENT_DATE;
  v_today_spin RECORD;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized' USING ERRCODE = '42501';
  END IF;

  SELECT prize_code, prize_label, reward_coins, metadata, created_at
  INTO v_today_spin
  FROM public.lucky_wheel_spins
  WHERE user_id = v_user_id
    AND spin_date = v_today
  LIMIT 1;

  RETURN jsonb_build_object(
    'success', TRUE,
    'can_spin_today', v_today_spin.prize_code IS NULL,
    'today_spin', CASE
      WHEN v_today_spin.prize_code IS NULL THEN NULL
      ELSE jsonb_build_object(
        'code', v_today_spin.prize_code,
        'label', v_today_spin.prize_label,
        'reward_coins', v_today_spin.reward_coins,
        'metadata', COALESCE(v_today_spin.metadata, '{}'::JSONB),
        'spun_at', v_today_spin.created_at
      )
    END,
    'total_spins', (
      SELECT COUNT(*)::INTEGER
      FROM public.lucky_wheel_spins
      WHERE user_id = v_user_id
    ),
    'balance', public.get_coin_balance_for_user(v_user_id)
  );
END;
$$;

-- 7) Lucky wheel spin RPC (server-side prize + anti-abuse)
CREATE OR REPLACE FUNCTION public.spin_lucky_wheel()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_today DATE := CURRENT_DATE;
  v_existing RECORD;
  v_roll NUMERIC := random() * 100;
  v_code TEXT := 'try_again';
  v_label TEXT := 'Try Again';
  v_reward INTEGER := 0;
  v_icon TEXT := 'ðŸ”„';
  v_balance INTEGER := 0;
  v_idempotency_key TEXT := format('lucky_wheel:%s', CURRENT_DATE::TEXT);
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized' USING ERRCODE = '42501';
  END IF;

  SELECT prize_code, prize_label, reward_coins, metadata, created_at
  INTO v_existing
  FROM public.lucky_wheel_spins
  WHERE user_id = v_user_id
    AND spin_date = v_today
  LIMIT 1;

  IF v_existing.prize_code IS NOT NULL THEN
    v_balance := public.get_coin_balance_for_user(v_user_id);
    RETURN jsonb_build_object(
      'success', FALSE,
      'already_spun', TRUE,
      'prize', jsonb_build_object(
        'code', v_existing.prize_code,
        'label', v_existing.prize_label,
        'reward_coins', v_existing.reward_coins,
        'metadata', COALESCE(v_existing.metadata, '{}'::JSONB),
        'spun_at', v_existing.created_at
      ),
      'balance', v_balance
    );
  END IF;

  -- Weighted server-side randomization
  -- 24% 10 coins, 20% 20 coins, 10% 50 coins, 22% try again,
  -- 15% 5 coins, 4% 100 coins, 4% 15 coins, 1% vip badge
  IF v_roll < 24 THEN
    v_code := 'coins_10';
    v_label := '10 Coins';
    v_reward := 10;
    v_icon := 'ðŸª™';
  ELSIF v_roll < 44 THEN
    v_code := 'coins_20';
    v_label := '20 Coins';
    v_reward := 20;
    v_icon := 'ðŸª™';
  ELSIF v_roll < 54 THEN
    v_code := 'coins_50';
    v_label := '50 Coins';
    v_reward := 50;
    v_icon := 'ðŸ’°';
  ELSIF v_roll < 76 THEN
    v_code := 'try_again';
    v_label := 'Try Again';
    v_reward := 0;
    v_icon := 'ðŸ”„';
  ELSIF v_roll < 91 THEN
    v_code := 'coins_5';
    v_label := '5 Coins';
    v_reward := 5;
    v_icon := 'ðŸª™';
  ELSIF v_roll < 95 THEN
    v_code := 'coins_100';
    v_label := '100 Coins';
    v_reward := 100;
    v_icon := 'ðŸŽ';
  ELSIF v_roll < 99 THEN
    v_code := 'coins_15';
    v_label := '15 Coins';
    v_reward := 15;
    v_icon := 'ðŸª™';
  ELSE
    v_code := 'vip_badge';
    v_label := 'VIP Badge';
    v_reward := 0;
    v_icon := 'â­';
  END IF;

  INSERT INTO public.lucky_wheel_spins (
    user_id,
    spin_date,
    prize_code,
    prize_label,
    reward_coins,
    metadata
  )
  VALUES (
    v_user_id,
    v_today,
    v_code,
    v_label,
    v_reward,
    jsonb_build_object(
      'icon', v_icon,
      'roll', round(v_roll::NUMERIC, 4)
    )
  );

  IF v_reward > 0
     AND NOT EXISTS (
       SELECT 1
       FROM public.coin_ledger
       WHERE user_id = v_user_id
         AND idempotency_key = v_idempotency_key
     ) THEN
    INSERT INTO public.coin_ledger (
      user_id,
      amount,
      description,
      transaction_type,
      idempotency_key,
      metadata
    )
    VALUES (
      v_user_id,
      v_reward,
      format('Lucky wheel reward: %s', v_label),
      'lucky_wheel',
      v_idempotency_key,
      jsonb_build_object(
        'prize_code', v_code,
        'prize_label', v_label,
        'icon', v_icon
      )
    );
  END IF;

  v_balance := public.get_coin_balance_for_user(v_user_id);

  RETURN jsonb_build_object(
    'success', TRUE,
    'already_spun', FALSE,
    'prize', jsonb_build_object(
      'code', v_code,
      'label', v_label,
      'reward_coins', v_reward,
      'metadata', jsonb_build_object('icon', v_icon)
    ),
    'balance', v_balance
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_coin_balance_for_user(UUID) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_daily_checkin_status() TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.claim_daily_checkin() TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_lucky_wheel_status() TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.spin_lucky_wheel() TO authenticated, service_role;
