-- Purpose: Add remote feature flags (with audit + RLS) and feed/search v2 foundations.
-- Safety: idempotent, SQL Editor safe
-- Affected objects: public.feature_flags, public.feature_flag_audit, public.feature_flags_public, public.venue_stats,
--   public.get_feed_cards_v2, public.refresh_venue_stats, public.venues(search_vector)
-- Risks (tier): High (schema + RLS + RPC + cron scheduling)
-- Rollback plan:
--   - DROP VIEW IF EXISTS public.feature_flags_public;
--   - DROP TABLE IF EXISTS public.feature_flag_audit;
--   - DROP TABLE IF EXISTS public.feature_flags;
--   - DROP FUNCTION IF EXISTS public.get_feed_cards_v2(DOUBLE PRECISION, DOUBLE PRECISION, INTEGER);
--   - DROP FUNCTION IF EXISTS public.refresh_venue_stats();
--   - DROP TABLE IF EXISTS public.venue_stats;
--   - ALTER TABLE public.venues DROP COLUMN IF EXISTS search_vector;

-- 0) Extensions used by search + scheduling.
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 1) Feature Flags (remote toggle source-of-truth).
CREATE TABLE IF NOT EXISTS public.feature_flags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT NOT NULL UNIQUE,
  description TEXT,
  enabled BOOLEAN NOT NULL DEFAULT FALSE,
  public BOOLEAN NOT NULL DEFAULT FALSE,
  rollout_percent INTEGER NOT NULL DEFAULT 100 CHECK (rollout_percent >= 0 AND rollout_percent <= 100),
  allowlist_roles TEXT[] NOT NULL DEFAULT '{}',
  allowlist_user_ids UUID[] NOT NULL DEFAULT '{}',
  target_paths TEXT[] NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by UUID
);

CREATE INDEX IF NOT EXISTS feature_flags_key_idx
  ON public.feature_flags (key);

CREATE INDEX IF NOT EXISTS feature_flags_public_enabled_idx
  ON public.feature_flags (public, enabled);

CREATE TABLE IF NOT EXISTS public.feature_flag_audit (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  flag_key TEXT NOT NULL,
  action TEXT NOT NULL,
  old_value JSONB,
  new_value JSONB,
  actor_user_id UUID,
  ip_hash TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS feature_flag_audit_flag_key_created_at_idx
  ON public.feature_flag_audit (flag_key, created_at DESC);

CREATE INDEX IF NOT EXISTS feature_flag_audit_actor_created_at_idx
  ON public.feature_flag_audit (actor_user_id, created_at DESC);

CREATE OR REPLACE FUNCTION public.set_feature_flags_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS feature_flags_set_updated_at_trg ON public.feature_flags;
CREATE TRIGGER feature_flags_set_updated_at_trg
BEFORE UPDATE ON public.feature_flags
FOR EACH ROW
EXECUTE FUNCTION public.set_feature_flags_updated_at();

CREATE OR REPLACE FUNCTION public.audit_feature_flag_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_action TEXT;
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_action := 'insert';
    INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
    VALUES (NEW.key, v_action, NULL, to_jsonb(NEW), auth.uid());
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    v_action := 'update';
    INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
    VALUES (NEW.key, v_action, to_jsonb(OLD), to_jsonb(NEW), auth.uid());
    RETURN NEW;
  END IF;

  v_action := 'delete';
  INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
  VALUES (OLD.key, v_action, to_jsonb(OLD), NULL, auth.uid());
  RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS feature_flags_audit_trg ON public.feature_flags;
CREATE TRIGGER feature_flags_audit_trg
AFTER INSERT OR UPDATE OR DELETE ON public.feature_flags
FOR EACH ROW
EXECUTE FUNCTION public.audit_feature_flag_changes();

-- Public projection (read-only, no sensitive fields).
CREATE OR REPLACE VIEW public.feature_flags_public AS
SELECT
  key,
  enabled,
  rollout_percent,
  allowlist_roles,
  allowlist_user_ids,
  target_paths,
  updated_at
FROM public.feature_flags
WHERE public = TRUE;

ALTER VIEW public.feature_flags_public SET (security_invoker = true, security_barrier = true);

GRANT SELECT ON public.feature_flags_public TO anon, authenticated;

-- Admin write guard via JWT app_metadata.roles + service_role.
CREATE OR REPLACE FUNCTION public.is_admin_or_service_role()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
AS $$
  SELECT
    COALESCE(auth.role() = 'service_role', FALSE)
    OR COALESCE((auth.jwt() -> 'app_metadata' ->> 'role') = 'admin', FALSE)
    OR COALESCE((auth.jwt() -> 'app_metadata' -> 'roles') ? 'admin', FALSE);
$$;

ALTER TABLE public.feature_flags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feature_flag_audit ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "feature_flags_select_public" ON public.feature_flags;
CREATE POLICY "feature_flags_select_public" ON public.feature_flags
  FOR SELECT TO anon, authenticated
  USING (public = TRUE);

DROP POLICY IF EXISTS "feature_flags_admin_write" ON public.feature_flags;
CREATE POLICY "feature_flags_admin_write" ON public.feature_flags
  FOR ALL TO authenticated
  USING (public.is_admin_or_service_role())
  WITH CHECK (public.is_admin_or_service_role());

DROP POLICY IF EXISTS "feature_flags_service_all" ON public.feature_flags;
CREATE POLICY "feature_flags_service_all" ON public.feature_flags
  FOR ALL TO service_role
  USING (TRUE)
  WITH CHECK (TRUE);

DROP POLICY IF EXISTS "feature_flag_audit_admin_read" ON public.feature_flag_audit;
CREATE POLICY "feature_flag_audit_admin_read" ON public.feature_flag_audit
  FOR SELECT TO authenticated
  USING (public.is_admin_or_service_role());

DROP POLICY IF EXISTS "feature_flag_audit_service_all" ON public.feature_flag_audit;
CREATE POLICY "feature_flag_audit_service_all" ON public.feature_flag_audit
  FOR ALL TO service_role
  USING (TRUE)
  WITH CHECK (TRUE);

-- 2) Feed/Search v2 foundation: search vector + venue stats rollup.
ALTER TABLE public.venues
  ADD COLUMN IF NOT EXISTS search_vector tsvector;

CREATE OR REPLACE FUNCTION public.safe_to_double(p_text TEXT)
RETURNS DOUBLE PRECISION
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN p_text IS NULL THEN NULL
    WHEN p_text ~ '^-?[0-9]+(\.[0-9]+)?$' THEN p_text::DOUBLE PRECISION
    ELSE NULL
  END;
$$;

CREATE OR REPLACE FUNCTION public.set_venue_search_vector()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_doc TEXT;
BEGIN
  v_doc := concat_ws(
    ' ',
    COALESCE(NEW.name, ''),
    COALESCE(NEW.category, ''),
    COALESCE(NEW.description, ''),
    COALESCE(to_jsonb(NEW) ->> 'address', ''),
    COALESCE(to_jsonb(NEW) ->> 'district', ''),
    COALESCE(to_jsonb(NEW) ->> 'province', '')
  );

  NEW.search_vector := to_tsvector('simple', v_doc);
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS venues_set_search_vector_trg ON public.venues;
CREATE TRIGGER venues_set_search_vector_trg
BEFORE INSERT OR UPDATE OF name, category, description, address, district, province
ON public.venues
FOR EACH ROW
EXECUTE FUNCTION public.set_venue_search_vector();

-- Backfill current rows (safe to rerun).
UPDATE public.venues
SET search_vector = to_tsvector(
  'simple',
  concat_ws(
    ' ',
    COALESCE(name, ''),
    COALESCE(category, ''),
    COALESCE(description, ''),
    COALESCE(to_jsonb(venues) ->> 'address', ''),
    COALESCE(to_jsonb(venues) ->> 'district', ''),
    COALESCE(to_jsonb(venues) ->> 'province', '')
  )
)
WHERE search_vector IS NULL;

CREATE INDEX IF NOT EXISTS venues_search_vector_gin_idx
  ON public.venues USING GIN (search_vector);

CREATE INDEX IF NOT EXISTS venues_name_trgm_idx
  ON public.venues USING GIN (name gin_trgm_ops);

CREATE TABLE IF NOT EXISTS public.venue_stats (
  venue_id UUID PRIMARY KEY REFERENCES public.venues(id) ON DELETE CASCADE,
  views_24h INTEGER NOT NULL DEFAULT 0,
  clicks_24h INTEGER NOT NULL DEFAULT 0,
  calls_24h INTEGER NOT NULL DEFAULT 0,
  checkouts_24h INTEGER NOT NULL DEFAULT 0,
  paid_24h INTEGER NOT NULL DEFAULT 0,
  vibe_score NUMERIC(12, 2) NOT NULL DEFAULT 0,
  refreshed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS venue_stats_vibe_score_idx
  ON public.venue_stats (vibe_score DESC, refreshed_at DESC);

CREATE OR REPLACE FUNCTION public.refresh_venue_stats()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  WITH src AS (
    SELECT
      CASE
        WHEN shop_id::TEXT ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          THEN shop_id::TEXT::UUID
        ELSE NULL
      END AS venue_id,
      lower(COALESCE(event_type, '')) AS event_type
    FROM public.analytics_events_p
    WHERE created_at >= (NOW() - INTERVAL '24 hours')
  ),
  agg AS (
    SELECT
      venue_id,
      COUNT(*) FILTER (WHERE event_type IN ('view', 'page_view', 'venue_view')) AS views_24h,
      COUNT(*) FILTER (WHERE event_type IN ('click', 'tap')) AS clicks_24h,
      COUNT(*) FILTER (WHERE event_type IN ('call', 'click_call')) AS calls_24h,
      COUNT(*) FILTER (WHERE event_type IN ('checkout_start', 'checkout')) AS checkouts_24h,
      COUNT(*) FILTER (WHERE event_type IN ('paid', 'payment_success')) AS paid_24h
    FROM src
    WHERE venue_id IS NOT NULL
    GROUP BY venue_id
  )
  INSERT INTO public.venue_stats (
    venue_id, views_24h, clicks_24h, calls_24h, checkouts_24h, paid_24h, vibe_score, refreshed_at
  )
  SELECT
    a.venue_id,
    COALESCE(a.views_24h, 0),
    COALESCE(a.clicks_24h, 0),
    COALESCE(a.calls_24h, 0),
    COALESCE(a.checkouts_24h, 0),
    COALESCE(a.paid_24h, 0),
    (
      COALESCE(a.views_24h, 0) * 1.0 +
      COALESCE(a.clicks_24h, 0) * 1.5 +
      COALESCE(a.calls_24h, 0) * 2.0 +
      COALESCE(a.checkouts_24h, 0) * 3.0 +
      COALESCE(a.paid_24h, 0) * 5.0
    )::NUMERIC(12, 2) AS vibe_score,
    NOW()
  FROM agg a
  ON CONFLICT (venue_id) DO UPDATE
  SET
    views_24h = EXCLUDED.views_24h,
    clicks_24h = EXCLUDED.clicks_24h,
    calls_24h = EXCLUDED.calls_24h,
    checkouts_24h = EXCLUDED.checkouts_24h,
    paid_24h = EXCLUDED.paid_24h,
    vibe_score = EXCLUDED.vibe_score,
    refreshed_at = NOW();

  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN COALESCE(v_rows, 0);
END;
$$;

GRANT EXECUTE ON FUNCTION public.refresh_venue_stats() TO service_role;

CREATE OR REPLACE FUNCTION public.get_feed_cards_v2(
  p_lat DOUBLE PRECISION,
  p_lng DOUBLE PRECISION,
  p_limit INTEGER DEFAULT 30
)
RETURNS TABLE (
  id UUID,
  slug TEXT,
  short_code TEXT,
  name TEXT,
  category TEXT,
  distance_km DOUBLE PRECISION,
  pin_type TEXT,
  is_verified BOOLEAN,
  boost_active BOOLEAN,
  giant_active BOOLEAN,
  vibe_score NUMERIC,
  hero_image TEXT,
  status TEXT
)
LANGUAGE sql
STABLE
AS $$
  WITH base AS (
    SELECT
      v.id,
      NULLIF(v.slug, '') AS slug,
      NULLIF(v.short_code, '') AS short_code,
      v.name,
      v.category,
      v.pin_type::TEXT AS pin_type,
      COALESCE(v.is_verified, FALSE) AS is_verified,
      (v.boost_until IS NOT NULL AND v.boost_until > NOW()) AS boost_active,
      (v.giant_until IS NOT NULL AND v.giant_until > NOW()) AS giant_active,
      COALESCE(vs.vibe_score, 0)::NUMERIC AS vibe_score,
      COALESCE((v.image_urls)[1], to_jsonb(v) ->> 'Image_URL1') AS hero_image,
      COALESCE(v.status, 'active') AS status,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'latitude', to_jsonb(v) ->> 'lat')) AS lat,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'longitude', to_jsonb(v) ->> 'lng')) AS lng
    FROM public.venues v
    LEFT JOIN public.venue_stats vs ON vs.venue_id = v.id
    WHERE COALESCE(v.status, 'active') <> 'OFF'
  )
  SELECT
    b.id,
    b.slug,
    b.short_code,
    b.name,
    b.category,
    CASE
      WHEN b.lat IS NULL OR b.lng IS NULL OR p_lat IS NULL OR p_lng IS NULL THEN NULL
      ELSE ROUND(
        (
          ST_Distance(
            ST_SetSRID(ST_MakePoint(b.lng, b.lat), 4326)::geography,
            ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography
          ) / 1000.0
        )::NUMERIC,
        2
      )::DOUBLE PRECISION
    END AS distance_km,
    b.pin_type,
    b.is_verified,
    b.boost_active,
    b.giant_active,
    b.vibe_score,
    b.hero_image,
    b.status
  FROM base b
  ORDER BY
    CASE WHEN b.giant_active THEN 1 ELSE 0 END DESC,
    CASE WHEN b.boost_active THEN 1 ELSE 0 END DESC,
    b.vibe_score DESC,
    distance_km ASC NULLS LAST,
    b.name ASC
  LIMIT GREATEST(COALESCE(p_limit, 30), 1);
$$;

GRANT EXECUTE ON FUNCTION public.get_feed_cards_v2(DOUBLE PRECISION, DOUBLE PRECISION, INTEGER)
  TO anon, authenticated, service_role;

-- 3) Schedule stats refresh every 15 minutes (best-effort, pg_cron optional).
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron')
     AND EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'cron') THEN
    PERFORM cron.unschedule(jobid)
    FROM cron.job
    WHERE jobname = 'refresh_venue_stats_15m';

    PERFORM cron.schedule(
      'refresh_venue_stats_15m',
      '*/15 * * * *',
      $cron$SELECT public.refresh_venue_stats();$cron$
    );
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'pg_cron schedule skipped: %', SQLERRM;
END;
$$;
