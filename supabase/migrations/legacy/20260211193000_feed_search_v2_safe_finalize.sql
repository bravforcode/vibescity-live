-- Purpose: Safe, canonical feed/search v2 finalization for prod/staging parity.
-- Safety: idempotent, SQL Editor safe, forward-fix only.
-- Affected objects: public.venues, public.venue_stats, public.feature_flags, public.feature_flag_audit,
--                   public.feature_flags_public, public.refresh_venue_stats,
--                   public.get_feed_cards_v2, public.search_venues_v2.
-- Risks (tier): High (RPC signatures, RLS, cron schedule)
-- Rollback plan:
--   1) Keep use_v2_feed/use_v2_search disabled (false).
--   2) Restore prior function definitions from pre-deploy snapshot.
--   3) Unschedule refresh_venue_stats_15m_v2_safe if cron behavior regresses.

CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 1) Canonical venue columns required by v2 APIs.
ALTER TABLE public.venues
  ADD COLUMN IF NOT EXISTS name_en TEXT,
  ADD COLUMN IF NOT EXISTS name_th TEXT,
  ADD COLUMN IF NOT EXISTS search_vector tsvector;

UPDATE public.venues
SET name_en = name
WHERE name_en IS NULL
  AND name IS NOT NULL;

CREATE OR REPLACE FUNCTION public.safe_to_double(p_text TEXT)
RETURNS DOUBLE PRECISION
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN p_text IS NULL THEN NULL
    WHEN btrim(p_text) ~ '^-?[0-9]+(\.[0-9]+)?$' THEN btrim(p_text)::DOUBLE PRECISION
    ELSE NULL
  END;
$$;

CREATE OR REPLACE FUNCTION public.set_venue_search_vector_v2_safe()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_doc TEXT;
BEGIN
  v_doc := concat_ws(
    ' ',
    COALESCE(NEW.name, ''),
    COALESCE(NEW.name_en, ''),
    COALESCE(NEW.name_th, ''),
    COALESCE(NEW.category, ''),
    COALESCE(NEW.description, ''),
    COALESCE(NEW.floor, ''),
    COALESCE(to_jsonb(NEW) ->> 'zone', ''),
    COALESCE(to_jsonb(NEW) ->> 'Zone', ''),
    COALESCE(NEW.district, ''),
    COALESCE(NEW.province, '')
  );

  NEW.search_vector := to_tsvector('simple', v_doc);
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS venues_search_vector_trigger ON public.venues;
DROP TRIGGER IF EXISTS venues_set_search_vector_trg ON public.venues;
DROP TRIGGER IF EXISTS venues_search_vector_v2_trg ON public.venues;
DROP TRIGGER IF EXISTS venues_search_vector_v2_safe_trg ON public.venues;

CREATE TRIGGER venues_search_vector_v2_safe_trg
BEFORE INSERT OR UPDATE OF name, name_en, name_th, category, description, floor, district, province
ON public.venues
FOR EACH ROW
EXECUTE FUNCTION public.set_venue_search_vector_v2_safe();

UPDATE public.venues v
SET search_vector = to_tsvector(
  'simple',
  concat_ws(
    ' ',
    COALESCE(v.name, ''),
    COALESCE(v.name_en, ''),
    COALESCE(v.name_th, ''),
    COALESCE(v.category, ''),
    COALESCE(v.description, ''),
    COALESCE(v.floor, ''),
    COALESCE(to_jsonb(v) ->> 'zone', ''),
    COALESCE(to_jsonb(v) ->> 'Zone', ''),
    COALESCE(v.district, ''),
    COALESCE(v.province, '')
  )
)
WHERE v.search_vector IS NULL;

CREATE INDEX IF NOT EXISTS venues_search_vector_gin_v2_safe_idx
  ON public.venues USING GIN (search_vector);

CREATE INDEX IF NOT EXISTS venues_name_trgm_v2_safe_idx
  ON public.venues USING GIN (name gin_trgm_ops);

-- 2) Feature flags with audit + RLS.
CREATE TABLE IF NOT EXISTS public.feature_flags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT NOT NULL UNIQUE,
  description TEXT,
  enabled BOOLEAN NOT NULL DEFAULT FALSE,
  public BOOLEAN NOT NULL DEFAULT FALSE,
  rollout_percent INTEGER NOT NULL DEFAULT 100 CHECK (rollout_percent >= 0 AND rollout_percent <= 100),
  allowlist_roles TEXT[] NOT NULL DEFAULT '{}',
  allowlist_user_ids UUID[] NOT NULL DEFAULT '{}',
  target_paths TEXT[] NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by UUID
);

CREATE INDEX IF NOT EXISTS feature_flags_key_idx
  ON public.feature_flags (key);

CREATE INDEX IF NOT EXISTS feature_flags_public_enabled_idx
  ON public.feature_flags (public, enabled);

CREATE TABLE IF NOT EXISTS public.feature_flag_audit (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  flag_key TEXT NOT NULL,
  action TEXT NOT NULL,
  old_value JSONB,
  new_value JSONB,
  actor_user_id UUID,
  ip_hash TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS feature_flag_audit_flag_key_created_at_idx
  ON public.feature_flag_audit (flag_key, created_at DESC);

CREATE INDEX IF NOT EXISTS feature_flag_audit_actor_created_at_idx
  ON public.feature_flag_audit (actor_user_id, created_at DESC);

CREATE OR REPLACE FUNCTION public.set_feature_flags_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS feature_flags_set_updated_at_trg ON public.feature_flags;
CREATE TRIGGER feature_flags_set_updated_at_trg
BEFORE UPDATE ON public.feature_flags
FOR EACH ROW
EXECUTE FUNCTION public.set_feature_flags_updated_at();

CREATE OR REPLACE FUNCTION public.audit_feature_flag_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_action TEXT;
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_action := 'insert';
    INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
    VALUES (NEW.key, v_action, NULL, to_jsonb(NEW), auth.uid());
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    v_action := 'update';
    INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
    VALUES (NEW.key, v_action, to_jsonb(OLD), to_jsonb(NEW), auth.uid());
    RETURN NEW;
  END IF;

  v_action := 'delete';
  INSERT INTO public.feature_flag_audit (flag_key, action, old_value, new_value, actor_user_id)
  VALUES (OLD.key, v_action, to_jsonb(OLD), NULL, auth.uid());
  RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS feature_flags_audit_trg ON public.feature_flags;
CREATE TRIGGER feature_flags_audit_trg
AFTER INSERT OR UPDATE OR DELETE ON public.feature_flags
FOR EACH ROW
EXECUTE FUNCTION public.audit_feature_flag_changes();

CREATE OR REPLACE VIEW public.feature_flags_public AS
SELECT
  key,
  enabled,
  rollout_percent,
  allowlist_roles,
  allowlist_user_ids,
  target_paths,
  updated_at
FROM public.feature_flags
WHERE public = TRUE;

ALTER VIEW public.feature_flags_public
  SET (security_invoker = true, security_barrier = true);

GRANT SELECT ON public.feature_flags_public TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.is_admin_or_service_role()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
AS $$
  SELECT
    COALESCE(auth.role() = 'service_role', FALSE)
    OR COALESCE((auth.jwt() -> 'app_metadata' ->> 'role') = 'admin', FALSE)
    OR COALESCE((auth.jwt() -> 'app_metadata' -> 'roles') ? 'admin', FALSE);
$$;

ALTER TABLE public.feature_flags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feature_flag_audit ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "feature_flags_select_public" ON public.feature_flags;
CREATE POLICY "feature_flags_select_public" ON public.feature_flags
  FOR SELECT TO anon, authenticated
  USING (public = TRUE);

DROP POLICY IF EXISTS "feature_flags_admin_write" ON public.feature_flags;
CREATE POLICY "feature_flags_admin_write" ON public.feature_flags
  FOR ALL TO authenticated
  USING (public.is_admin_or_service_role())
  WITH CHECK (public.is_admin_or_service_role());

DROP POLICY IF EXISTS "feature_flags_service_all" ON public.feature_flags;
CREATE POLICY "feature_flags_service_all" ON public.feature_flags
  FOR ALL TO service_role
  USING (TRUE)
  WITH CHECK (TRUE);

DROP POLICY IF EXISTS "feature_flag_audit_admin_read" ON public.feature_flag_audit;
CREATE POLICY "feature_flag_audit_admin_read" ON public.feature_flag_audit
  FOR SELECT TO authenticated
  USING (public.is_admin_or_service_role());

DROP POLICY IF EXISTS "feature_flag_audit_service_all" ON public.feature_flag_audit;
CREATE POLICY "feature_flag_audit_service_all" ON public.feature_flag_audit
  FOR ALL TO service_role
  USING (TRUE)
  WITH CHECK (TRUE);

-- 3) venue_stats rollup surface for v2 feed/search.
CREATE TABLE IF NOT EXISTS public.venue_stats (
  venue_id UUID PRIMARY KEY REFERENCES public.venues(id) ON DELETE CASCADE
);

ALTER TABLE public.venue_stats
  ADD COLUMN IF NOT EXISTS total_views BIGINT NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS checkin_count_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS view_count BIGINT NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS views_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS clicks_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS calls_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS checkouts_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS paid_24h INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS vibe_score NUMERIC(12, 2) NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS ranking_score NUMERIC(14, 2) NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS refreshed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();

CREATE INDEX IF NOT EXISTS venue_stats_ranking_score_v2_safe_idx
  ON public.venue_stats (ranking_score DESC, refreshed_at DESC);

ALTER TABLE public.venue_stats ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "venue_stats_select_public" ON public.venue_stats;
CREATE POLICY "venue_stats_select_public" ON public.venue_stats
  FOR SELECT TO anon, authenticated
  USING (true);

DROP POLICY IF EXISTS "venue_stats_service_all" ON public.venue_stats;
CREATE POLICY "venue_stats_service_all" ON public.venue_stats
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

CREATE OR REPLACE FUNCTION public.refresh_venue_stats()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_rows INTEGER := 0;
BEGIN
  IF to_regclass('public.analytics_events_p') IS NULL THEN
    RETURN 0;
  END IF;

  WITH src AS (
    SELECT
      CASE
        WHEN COALESCE(
          NULLIF(venue_ref, ''),
          NULLIF(metadata ->> 'venue_ref', ''),
          NULLIF(metadata ->> 'venue_id', ''),
          NULLIF(metadata ->> 'shop_id', ''),
          shop_id::TEXT
        ) ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
        THEN COALESCE(
          NULLIF(venue_ref, ''),
          NULLIF(metadata ->> 'venue_ref', ''),
          NULLIF(metadata ->> 'venue_id', ''),
          NULLIF(metadata ->> 'shop_id', ''),
          shop_id::TEXT
        )::UUID
        ELSE NULL
      END AS venue_id,
      lower(COALESCE(event_type, '')) AS event_type,
      COALESCE(metadata, '{}'::jsonb) AS metadata
    FROM public.analytics_events_p
    WHERE created_at >= (NOW() - INTERVAL '24 hours')
  ),
  agg AS (
    SELECT
      venue_id,
      COUNT(*) FILTER (
        WHERE
          event_type = 'open_detail'
          OR (
            event_type = 'video_view'
            AND GREATEST(
              COALESCE(public.safe_to_double(metadata ->> 'view_seconds'), 0),
              COALESCE(public.safe_to_double(metadata ->> 'watch_seconds'), 0),
              COALESCE(public.safe_to_double(metadata ->> 'duration_seconds'), 0),
              COALESCE(public.safe_to_double(metadata ->> 'duration_ms') / 1000.0, 0)
            ) >= 3
          )
      ) AS total_views,
      COUNT(*) FILTER (WHERE event_type = 'checkin_confirm') AS checkin_count_24h,
      COUNT(*) FILTER (WHERE event_type IN ('click', 'tap')) AS clicks_24h,
      COUNT(*) FILTER (WHERE event_type IN ('call', 'click_call')) AS calls_24h,
      COUNT(*) FILTER (WHERE event_type IN ('checkout_start', 'checkout')) AS checkouts_24h,
      COUNT(*) FILTER (WHERE event_type IN ('paid', 'payment_success', 'invoice.payment_succeeded')) AS paid_24h
    FROM src
    WHERE venue_id IS NOT NULL
    GROUP BY venue_id
  )
  INSERT INTO public.venue_stats (
    venue_id,
    total_views,
    view_count,
    views_24h,
    checkin_count_24h,
    clicks_24h,
    calls_24h,
    checkouts_24h,
    paid_24h,
    vibe_score,
    ranking_score,
    refreshed_at,
    updated_at
  )
  SELECT
    a.venue_id,
    COALESCE(a.total_views, 0),
    COALESCE(a.total_views, 0),
    COALESCE(a.total_views, 0)::INTEGER,
    COALESCE(a.checkin_count_24h, 0),
    COALESCE(a.clicks_24h, 0),
    COALESCE(a.calls_24h, 0),
    COALESCE(a.checkouts_24h, 0),
    COALESCE(a.paid_24h, 0),
    (
      COALESCE(a.total_views, 0) * 1.0 +
      COALESCE(a.checkin_count_24h, 0) * 2.0 +
      COALESCE(a.clicks_24h, 0) * 0.5 +
      COALESCE(a.checkouts_24h, 0) * 2.5 +
      COALESCE(a.paid_24h, 0) * 4.0
    )::NUMERIC(12, 2) AS vibe_score,
    (
      COALESCE(a.total_views, 0) * 1.0 +
      COALESCE(a.checkin_count_24h, 0) * 3.0 +
      COALESCE(a.paid_24h, 0) * 5.0
    )::NUMERIC(14, 2) AS ranking_score,
    NOW(),
    NOW()
  FROM agg a
  ON CONFLICT (venue_id) DO UPDATE
  SET
    total_views = EXCLUDED.total_views,
    view_count = EXCLUDED.view_count,
    views_24h = EXCLUDED.views_24h,
    checkin_count_24h = EXCLUDED.checkin_count_24h,
    clicks_24h = EXCLUDED.clicks_24h,
    calls_24h = EXCLUDED.calls_24h,
    checkouts_24h = EXCLUDED.checkouts_24h,
    paid_24h = EXCLUDED.paid_24h,
    vibe_score = EXCLUDED.vibe_score,
    ranking_score = EXCLUDED.ranking_score,
    refreshed_at = NOW(),
    updated_at = NOW();

  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN COALESCE(v_rows, 0);
END;
$$;

-- Remove incompatible legacy signatures to avoid RPC ambiguity.
DROP FUNCTION IF EXISTS public.get_feed_cards_v2(INTEGER, INTEGER, DOUBLE PRECISION, DOUBLE PRECISION, TEXT[], BOOLEAN);
DROP FUNCTION IF EXISTS public.get_feed_cards_v2(DOUBLE PRECISION, DOUBLE PRECISION, INTEGER);
DROP FUNCTION IF EXISTS public.search_venues_v2(TEXT, INTEGER);

CREATE OR REPLACE FUNCTION public.get_feed_cards_v2(
  p_lat DOUBLE PRECISION DEFAULT NULL,
  p_lng DOUBLE PRECISION DEFAULT NULL,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
)
RETURNS TABLE (
  id UUID,
  name TEXT,
  slug TEXT,
  image_url TEXT,
  category TEXT,
  rating NUMERIC,
  status TEXT,
  distance_meters DOUBLE PRECISION,
  view_count BIGINT
)
LANGUAGE sql
STABLE
AS $$
  WITH base AS (
    SELECT
      v.id,
      v.name,
      NULLIF(v.slug, '') AS slug,
      COALESCE((v.image_urls)[1], to_jsonb(v) ->> 'Image_URL1') AS image_url,
      v.category,
      COALESCE(v.rating, 0)::NUMERIC AS rating,
      COALESCE(v.status, 'OPEN') AS status,
      COALESCE(vs.total_views, vs.view_count, 0)::BIGINT AS view_count,
      (
        CASE
          WHEN lower(COALESCE(v.pin_metadata ->> 'is_promoted', '')) IN ('true', 't', '1', 'yes', 'y') THEN TRUE
          ELSE FALSE
        END
        OR (v.boost_until IS NOT NULL AND v.boost_until > NOW())
        OR COALESCE(v.visibility_score, 0) > 0
      ) AS is_promoted,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'latitude', to_jsonb(v) ->> 'lat')) AS lat,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'longitude', to_jsonb(v) ->> 'lng')) AS lng
    FROM public.venues v
    LEFT JOIN public.venue_stats vs ON vs.venue_id = v.id
    WHERE upper(COALESCE(v.status, 'OPEN')) NOT IN ('OFF', 'INACTIVE')
  )
  SELECT
    b.id,
    b.name,
    b.slug,
    b.image_url,
    b.category,
    b.rating,
    b.status,
    CASE
      WHEN b.lat IS NULL OR b.lng IS NULL OR p_lat IS NULL OR p_lng IS NULL THEN NULL
      ELSE ST_Distance(
        ST_SetSRID(ST_MakePoint(b.lng, b.lat), 4326)::geography,
        ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography
      )
    END AS distance_meters,
    b.view_count
  FROM base b
  ORDER BY
    CASE WHEN b.is_promoted THEN 1 ELSE 0 END DESC,
    CASE WHEN upper(COALESCE(b.status, '')) = 'LIVE' THEN 1 ELSE 0 END DESC,
    distance_meters ASC NULLS LAST,
    b.view_count DESC,
    b.name ASC
  LIMIT GREATEST(COALESCE(p_limit, 20), 1)
  OFFSET GREATEST(COALESCE(p_offset, 0), 0);
$$;

CREATE OR REPLACE FUNCTION public.search_venues_v2(
  p_query TEXT,
  p_lat DOUBLE PRECISION DEFAULT NULL,
  p_lng DOUBLE PRECISION DEFAULT NULL,
  p_radius_meters DOUBLE PRECISION DEFAULT NULL,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
)
RETURNS TABLE (
  id UUID,
  name TEXT,
  slug TEXT,
  image_url TEXT,
  category TEXT,
  rating NUMERIC,
  status TEXT,
  distance_meters DOUBLE PRECISION,
  view_count BIGINT,
  highlight_snippet TEXT,
  floor TEXT,
  zone TEXT
)
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_query TEXT := trim(COALESCE(p_query, ''));
  v_tsquery tsquery;
BEGIN
  IF v_query = '' THEN
    RETURN;
  END IF;

  BEGIN
    v_tsquery := websearch_to_tsquery('simple', v_query);
  EXCEPTION WHEN OTHERS THEN
    v_tsquery := plainto_tsquery('simple', v_query);
  END;

  RETURN QUERY
  WITH base AS (
    SELECT
      v.id,
      v.name,
      NULLIF(v.slug, '') AS slug,
      COALESCE((v.image_urls)[1], to_jsonb(v) ->> 'Image_URL1') AS image_url,
      v.category,
      COALESCE(v.rating, 0)::NUMERIC AS rating,
      COALESCE(v.status, 'OPEN') AS status,
      COALESCE(vs.total_views, vs.view_count, 0)::BIGINT AS view_count,
      COALESCE(v.floor, NULLIF(to_jsonb(v) ->> 'Floor', '')) AS floor,
      COALESCE(NULLIF(to_jsonb(v) ->> 'zone', ''), NULLIF(to_jsonb(v) ->> 'Zone', ''), v.district) AS zone,
      (
        CASE
          WHEN lower(COALESCE(v.pin_metadata ->> 'is_promoted', '')) IN ('true', 't', '1', 'yes', 'y') THEN TRUE
          ELSE FALSE
        END
        OR (v.boost_until IS NOT NULL AND v.boost_until > NOW())
        OR COALESCE(v.visibility_score, 0) > 0
      ) AS is_promoted,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'latitude', to_jsonb(v) ->> 'lat')) AS lat,
      public.safe_to_double(COALESCE(to_jsonb(v) ->> 'longitude', to_jsonb(v) ->> 'lng')) AS lng,
      ts_rank_cd(COALESCE(v.search_vector, ''::tsvector), v_tsquery) AS search_rank,
      ts_headline(
        'simple',
        concat_ws(' ', v.name, v.category, v.description),
        v_tsquery,
        'StartSel=<mark>, StopSel=</mark>, MaxWords=18, MinWords=6'
      ) AS highlight_snippet
    FROM public.venues v
    LEFT JOIN public.venue_stats vs ON vs.venue_id = v.id
    WHERE
      upper(COALESCE(v.status, 'OPEN')) NOT IN ('OFF', 'INACTIVE')
      AND (
        COALESCE(v.search_vector, ''::tsvector) @@ v_tsquery
        OR v.name ILIKE (v_query || '%')
        OR v.name_en ILIKE (v_query || '%')
        OR v.name_th ILIKE (v_query || '%')
      )
  ),
  with_dist AS (
    SELECT
      b.*,
      CASE
        WHEN b.lat IS NULL OR b.lng IS NULL OR p_lat IS NULL OR p_lng IS NULL THEN NULL
        ELSE ST_Distance(
          ST_SetSRID(ST_MakePoint(b.lng, b.lat), 4326)::geography,
          ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography
        )
      END AS distance_meters
    FROM base b
  )
  SELECT
    w.id,
    w.name,
    w.slug,
    w.image_url,
    w.category,
    w.rating,
    w.status,
    w.distance_meters,
    w.view_count,
    w.highlight_snippet,
    w.floor,
    w.zone
  FROM with_dist w
  WHERE p_radius_meters IS NULL OR w.distance_meters IS NULL OR w.distance_meters <= p_radius_meters
  ORDER BY
    CASE WHEN w.is_promoted THEN 1 ELSE 0 END DESC,
    CASE WHEN upper(COALESCE(w.status, '')) = 'LIVE' THEN 1 ELSE 0 END DESC,
    w.search_rank DESC,
    w.distance_meters ASC NULLS LAST,
    w.view_count DESC,
    w.name ASC
  LIMIT GREATEST(COALESCE(p_limit, 20), 1)
  OFFSET GREATEST(COALESCE(p_offset, 0), 0);
END;
$$;

GRANT EXECUTE ON FUNCTION public.refresh_venue_stats() TO service_role;
GRANT EXECUTE ON FUNCTION public.get_feed_cards_v2(DOUBLE PRECISION, DOUBLE PRECISION, INTEGER, INTEGER) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.search_venues_v2(TEXT, DOUBLE PRECISION, DOUBLE PRECISION, DOUBLE PRECISION, INTEGER, INTEGER) TO anon, authenticated, service_role;

-- 4) Best-effort cron schedule for stats refresh.
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron')
     AND EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'cron') THEN
    PERFORM cron.unschedule(jobid)
    FROM cron.job
    WHERE jobname IN ('refresh_venue_stats_15m', 'refresh_venue_stats_15m_v2', 'refresh_venue_stats_15m_v2_safe');

    PERFORM cron.schedule(
      'refresh_venue_stats_15m_v2_safe',
      '*/15 * * * *',
      $cron$SELECT public.refresh_venue_stats();$cron$
    );
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'pg_cron schedule skipped: %', SQLERRM;
END;
$$;

-- 5) Seed default feature flags (safe rollout defaults: v2 flags OFF).
INSERT INTO public.feature_flags (key, description, enabled, public)
VALUES
  ('use_v2_feed', 'Use feed/search RPC v2 for public feed', FALSE, TRUE),
  ('use_v2_search', 'Use search RPC v2 for global search', FALSE, TRUE),
  ('enable_web_vitals', 'Collect client web-vitals via analytics-ingest', FALSE, TRUE),
  ('enable_partner_program', 'Enable partner program MVP surface', FALSE, TRUE),
  ('enable_cinema_mall_explorer', 'Enable giant-pin cinema mall explorer overlay', FALSE, TRUE)
ON CONFLICT (key) DO UPDATE
SET
  description = EXCLUDED.description,
  public = EXCLUDED.public,
  enabled = CASE
    WHEN feature_flags.key IN ('use_v2_feed', 'use_v2_search') THEN FALSE
    ELSE feature_flags.enabled
  END;

